<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>7セグ認識 Webアプリ v7（ちらつき防止 + 誤認識ゲート + 細い「1」対策）</title>
<style>
  body { font-family: system-ui, -apple-system, sans-serif; margin: 0; background:#111; color:#eee; }
  .wrap { display:flex; flex-direction:column; gap:10px; padding:10px; max-width:1100px; margin:0 auto; }
  .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  button, select, input { font-size:16px; padding:8px 10px; }
  .stage { position:relative; width:100%; aspect-ratio: 16/9; background:#000; overflow:hidden; border-radius:10px; }
  video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; }
  .roi {
    position:absolute;
    border:2px solid rgba(255,0,0,.9);
    box-shadow: 0 0 0 9999px rgba(0,0,0,.35);
    border-radius:8px;
    pointer-events:none;
  }
  .panel { background:#1b1b1b; padding:10px; border-radius:10px; }
  .k { color:#9ad; }
  .big { font-size:36px; font-weight:900; letter-spacing: .5px; display:flex; align-items:center; gap:10px; }
  .sub { font-size:14px; color:#cfcfcf; margin-top:4px; }
  .hint { color:#bbb; font-size:13px; line-height:1.45; }
  .grid { display:grid; grid-template-columns: 1.1fr 0.9fr; gap:10px; }
  @media (max-width: 820px){ .grid { grid-template-columns: 1fr; } }
  .chip { display:flex; align-items:center; gap:6px; background:#222; padding:6px 8px; border-radius:999px; }
  details { background:#151515; border-radius:10px; padding:8px 10px; }
  details summary { cursor:pointer; }
  .kv { display:grid; grid-template-columns: 140px 1fr 70px; gap:8px; align-items:center; margin-top:8px;}
  .kv label{ color:#bbb; font-size:13px;}
  .kv input[type=range]{ width:100%; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
  .lamp{ width:12px; height:12px; border-radius:999px; background:#555; box-shadow:0 0 0 2px rgba(255,255,255,.08) inset; }
  .lamp.green{ background:#1fe36d; }
  .lamp.yellow{ background:#ffd34d; }
  .btn { background:#2a2a2a; border:1px solid #3a3a3a; color:#fff; border-radius:10px; }
  .btn:active{ transform:translateY(1px); }
  .smallinp{ width: 90px; padding:6px 8px; border-radius:8px; border:1px solid #333; background:#101010; color:#fff; }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <button id="btnStart" class="btn">カメラ開始</button>
    <button id="btnStop" class="btn" disabled>停止</button>

    <label>カメラ</label>
    <select id="selCam"></select>

    <span class="chip"><input id="lockBack" type="checkbox" checked />背面固定</span>
    <span class="chip"><input id="invert" type="checkbox" checked />反転（黒い数字用）</span>
    <span class="chip"><input id="dilate" type="checkbox" />太らせる</span>

    <span class="chip"><input id="autoThr" type="checkbox" checked />自動2値化（Otsu）</span>
    <label>オフセット</label>
    <input id="thrOff" type="range" min="-80" max="80" value="0" />
    <span id="thrOffVal">0</span>

    <label>使用T</label>
    <span id="thrUsed" class="mono">—</span>

    <label>桁</label>
    <select id="digits">
      <option value="4" selected>4桁</option>
      <option value="5">5桁</option>
    </select>

    <label>小数点</label>
    <select id="decimal">
      <option value="auto" selected>自動（ドット検出）</option>
      <option value="last">最後の1桁前（xxx.x）</option>
      <option value="none">なし</option>
    </select>

    <label>セグ判定</label>
    <input id="segThr" type="range" min="0.18" max="0.65" step="0.01" value="0.34" />
    <span id="segThrVal">0.34</span>
  </div>

  <details>
    <summary>ちらつき防止（確定表示）</summary>
    <div class="row" style="margin-top:8px;">
      <span class="chip"><input id="stabilize" type="checkbox" checked />安定化ON</span>
      <span class="chip"><input id="hold" type="checkbox" checked />確定値ホールド</span>
      <span class="chip"><input id="showCand" type="checkbox" checked />候補値表示</span>
    </div>
    <div class="kv"><label>確定に必要な連続フレーム</label><input id="needFrames" type="range" min="1" max="20" step="1" value="6"><span id="needFramesVal"></span></div>
    <div class="kv"><label>確定に必要な信頼度</label><input id="needConf" type="range" min="0.30" max="0.95" step="0.01" value="0.55"><span id="needConfVal"></span></div>
    <div class="kv"><label>解析間隔（ms）</label><input id="anMs" type="range" min="30" max="250" step="10" value="90"><span id="anMsVal"></span></div>

    <hr style="border:0;border-top:1px solid #333;margin:10px 0;">
    <div class="row">
      <span class="chip"><input id="gateOn" type="checkbox" checked />誤認識ゲートON</span>
      <span class="chip"><input id="force1dp" type="checkbox" checked />小数1桁に揃える</span>
      <span class="chip">最小桁数 <input id="minDigits" class="smallinp" type="number" min="1" max="6" step="1" value="3"></span>
      <span class="chip">範囲 <input id="minVal" class="smallinp" type="number" step="0.1" value="10"> ～ <input id="maxVal" class="smallinp" type="number" step="0.1" value="250"></span>
    </div>
    <div class="hint" style="margin-top:8px;">
      ・「118」が「8.8」になる原因は、細い「1」が検出から落ちることがあるため。v7では <b>細い1も拾うようにBBOXを広めに</b> しています。<br>
      ・さらに誤認識ゲートで、<b>桁数が少なすぎる候補（例: 8.8）</b> や、<b>範囲外の値</b> を無視します（確定値は保持）。<br>
      ・まずはデフォ（最小桁=3、範囲10～250、小数1桁）でOK。
    </div>
  </details>

  <details>
    <summary>ROI調整（1回合わせたら保存されます）</summary>
    <div class="kv"><label>X</label><input id="roiX" type="range" min="0" max="1" step="0.01"><span id="roiXv"></span></div>
    <div class="kv"><label>Y</label><input id="roiY" type="range" min="0" max="1" step="0.01"><span id="roiYv"></span></div>
    <div class="kv"><label>W</label><input id="roiW" type="range" min="0.05" max="1" step="0.01"><span id="roiWv"></span></div>
    <div class="kv"><label>H</label><input id="roiH" type="range" min="0.05" max="1" step="0.01"><span id="roiHv"></span></div>
    <div class="row" style="margin-top:8px;">
      <button id="btnRoiReset" type="button" class="btn">ROIリセット（この機種向け）</button>
    </div>
    <div class="hint" style="margin-top:6px;">
      赤枠＝ROI、シアン枠＝数字の塊、黄色枠＝桁領域。<br>
      ※赤枠はなるべく「表示窓」だけを囲うほど安定します（周囲の印刷文字を入れない）。
    </div>
  </details>

  <div class="grid">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
      <div id="roi" class="roi"></div>
    </div>

    <div class="panel">
      <div><span class="k">表示（確定）</span></div>
      <div class="big"><span id="lamp" class="lamp"></span><span id="out">—</span></div>
      <div id="candLine" class="sub mono">候補: —</div>
      <div class="hint mono" id="dbg"></div>

      <div class="row" style="margin-top:10px;">
        <button id="btnCopy" class="btn" type="button">確定値をコピー</button>
        <span class="hint">（Excelなどへ貼り付け）</span>
      </div>
    </div>
  </div>

  <canvas id="work" style="display:none;"></canvas>
</div>

<script>
// ===== DOM =====
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const work = document.getElementById('work');
const ctxO = overlay.getContext('2d', { willReadFrequently:true });
const ctxW = work.getContext('2d', { willReadFrequently:true });

const btnStart = document.getElementById('btnStart');
const btnStop  = document.getElementById('btnStop');
const selCam   = document.getElementById('selCam');

const lockBack = document.getElementById('lockBack');
const invertEl = document.getElementById('invert');
const dilateEl = document.getElementById('dilate');

const autoThrEl = document.getElementById('autoThr');
const thrOffEl = document.getElementById('thrOff');
const thrOffVal = document.getElementById('thrOffVal');
const thrUsedEl = document.getElementById('thrUsed');

const digitsEl = document.getElementById('digits');
const decEl    = document.getElementById('decimal');
const segThrEl = document.getElementById('segThr');
const segThrVal= document.getElementById('segThrVal');

const stabilizeEl = document.getElementById('stabilize');
const holdEl = document.getElementById('hold');
const showCandEl = document.getElementById('showCand');
const needFramesEl = document.getElementById('needFrames');
const needFramesVal = document.getElementById('needFramesVal');
const needConfEl = document.getElementById('needConf');
const needConfVal = document.getElementById('needConfVal');
const anMsEl = document.getElementById('anMs');
const anMsVal = document.getElementById('anMsVal');

const gateOnEl = document.getElementById('gateOn');
const force1dpEl = document.getElementById('force1dp');
const minDigitsEl = document.getElementById('minDigits');
const minValEl = document.getElementById('minVal');
const maxValEl = document.getElementById('maxVal');

const outEl    = document.getElementById('out');
const candLine = document.getElementById('candLine');
const dbgEl    = document.getElementById('dbg');
const roiEl    = document.getElementById('roi');
const lampEl   = document.getElementById('lamp');
const btnCopy  = document.getElementById('btnCopy');

const roiX = document.getElementById('roiX');
const roiY = document.getElementById('roiY');
const roiW = document.getElementById('roiW');
const roiH = document.getElementById('roiH');
const roiXv = document.getElementById('roiXv');
const roiYv = document.getElementById('roiYv');
const roiWv = document.getElementById('roiWv');
const roiHv = document.getElementById('roiHv');
const btnRoiReset = document.getElementById('btnRoiReset');

let stream = null;
let rafId = null;

// ===== storage =====
const LS = {
  cam: "sevenseg_cam_deviceid",
  lock: "sevenseg_lockback",
  inv: "sevenseg_invert",
  dil: "sevenseg_dilate",
  segthr: "sevenseg_segthr",
  auto: "sevenseg_autothr",
  off: "sevenseg_throff",
  roi: "sevenseg_roi_v7",

  stab: "sevenseg_stab",
  hold: "sevenseg_hold",
  show: "sevenseg_showcand",
  nf: "sevenseg_needframes",
  nc: "sevenseg_needconf",
  an: "sevenseg_anms",

  gate: "sevenseg_gate",
  force: "sevenseg_force1dp",
  mind: "sevenseg_mindigits",
  minv: "sevenseg_minval",
  maxv: "sevenseg_maxval",
};

const defaultRoi = { x: 0.18, y: 0.44, w: 0.64, h: 0.18 };
let ROI = loadROI();

// ===== helpers =====
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function clamp01(v){ return clamp(v, 0, 1); }

// ===== ROI =====
function loadROI(){
  try{
    const s = localStorage.getItem(LS.roi);
    if(!s) return {...defaultRoi};
    const o = JSON.parse(s);
    return { x: clamp01(+o.x), y: clamp01(+o.y), w: clamp01(+o.w), h: clamp01(+o.h) };
  }catch(_){ return {...defaultRoi}; }
}
function saveROI(){ localStorage.setItem(LS.roi, JSON.stringify(ROI)); }

// ===== load settings =====
lockBack.checked = (localStorage.getItem(LS.lock) ?? "1") === "1";
invertEl.checked = (localStorage.getItem(LS.inv) ?? "1") === "1";
dilateEl.checked = (localStorage.getItem(LS.dil) ?? "0") === "1";
segThrEl.value = (localStorage.getItem(LS.segthr) ?? "0.34");
autoThrEl.checked = (localStorage.getItem(LS.auto) ?? "1") === "1";
thrOffEl.value = (localStorage.getItem(LS.off) ?? "0");

stabilizeEl.checked = (localStorage.getItem(LS.stab) ?? "1") === "1";
holdEl.checked = (localStorage.getItem(LS.hold) ?? "1") === "1";
showCandEl.checked = (localStorage.getItem(LS.show) ?? "1") === "1";
needFramesEl.value = (localStorage.getItem(LS.nf) ?? "6");
needConfEl.value = (localStorage.getItem(LS.nc) ?? "0.55");
anMsEl.value = (localStorage.getItem(LS.an) ?? "90");

gateOnEl.checked = (localStorage.getItem(LS.gate) ?? "1") === "1";
force1dpEl.checked = (localStorage.getItem(LS.force) ?? "1") === "1";
minDigitsEl.value = (localStorage.getItem(LS.mind) ?? "3");
minValEl.value = (localStorage.getItem(LS.minv) ?? "10");
maxValEl.value = (localStorage.getItem(LS.maxv) ?? "250");

function syncLabels(){
  segThrVal.textContent = Number(segThrEl.value).toFixed(2);
  thrOffVal.textContent = String(thrOffEl.value);

  needFramesVal.textContent = String(needFramesEl.value);
  needConfVal.textContent = Number(needConfEl.value).toFixed(2);
  anMsVal.textContent = String(anMsEl.value);

  candLine.style.display = showCandEl.checked ? "" : "none";

  roiX.value = ROI.x; roiY.value = ROI.y; roiW.value = ROI.w; roiH.value = ROI.h;
  roiXv.textContent = ROI.x.toFixed(2);
  roiYv.textContent = ROI.y.toFixed(2);
  roiWv.textContent = ROI.w.toFixed(2);
  roiHv.textContent = ROI.h.toFixed(2);
}
syncLabels();

function bindRoiSlider(sl, key){
  sl.addEventListener('input', ()=>{
    ROI[key] = clamp01(parseFloat(sl.value));
    if(key==="w") ROI.w = Math.max(0.05, ROI.w);
    if(key==="h") ROI.h = Math.max(0.05, ROI.h);
    ROI.x = clamp01(Math.min(ROI.x, 1-ROI.w));
    ROI.y = clamp01(Math.min(ROI.y, 1-ROI.h));
    syncLabels();
    saveROI();
    setRoiBox();
  });
}
bindRoiSlider(roiX,"x");
bindRoiSlider(roiY,"y");
bindRoiSlider(roiW,"w");
bindRoiSlider(roiH,"h");

btnRoiReset.onclick = ()=>{
  ROI = {...defaultRoi};
  saveROI();
  syncLabels();
  setRoiBox();
};

// persist
lockBack.addEventListener('change', ()=> localStorage.setItem(LS.lock, lockBack.checked ? "1":"0"));
invertEl.addEventListener('change', ()=> localStorage.setItem(LS.inv, invertEl.checked ? "1":"0"));
dilateEl.addEventListener('change', ()=> localStorage.setItem(LS.dil, dilateEl.checked ? "1":"0"));
segThrEl.addEventListener('input', ()=> { localStorage.setItem(LS.segthr, segThrEl.value); syncLabels(); });

autoThrEl.addEventListener('change', ()=> localStorage.setItem(LS.auto, autoThrEl.checked ? "1":"0"));
thrOffEl.addEventListener('input', ()=> { localStorage.setItem(LS.off, thrOffEl.value); syncLabels(); });

stabilizeEl.addEventListener('change', ()=> localStorage.setItem(LS.stab, stabilizeEl.checked ? "1":"0"));
holdEl.addEventListener('change', ()=> localStorage.setItem(LS.hold, holdEl.checked ? "1":"0"));
showCandEl.addEventListener('change', ()=> { localStorage.setItem(LS.show, showCandEl.checked ? "1":"0"); syncLabels(); });
needFramesEl.addEventListener('input', ()=> { localStorage.setItem(LS.nf, needFramesEl.value); syncLabels(); });
needConfEl.addEventListener('input', ()=> { localStorage.setItem(LS.nc, needConfEl.value); syncLabels(); });
anMsEl.addEventListener('input', ()=> { localStorage.setItem(LS.an, anMsEl.value); syncLabels(); });

gateOnEl.addEventListener('change', ()=> localStorage.setItem(LS.gate, gateOnEl.checked ? "1":"0"));
force1dpEl.addEventListener('change', ()=> localStorage.setItem(LS.force, force1dpEl.checked ? "1":"0"));
minDigitsEl.addEventListener('change', ()=> localStorage.setItem(LS.mind, minDigitsEl.value));
minValEl.addEventListener('change', ()=> localStorage.setItem(LS.minv, minValEl.value));
maxValEl.addEventListener('change', ()=> localStorage.setItem(LS.maxv, maxValEl.value));

// ===== camera selection =====
function isBackLabel(label){
  if(!label) return false;
  return /(back|rear|environment|背面|リア|後ろ)/i.test(label);
}
async function listCams({preserve=true, autoPickBack=true} = {}){
  const prev = preserve ? selCam.value : "";
  const saved = localStorage.getItem(LS.cam) || "";
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d => d.kind === 'videoinput');

  selCam.innerHTML = '';
  cams.forEach((c, i) => {
    const opt = document.createElement('option');
    opt.value = c.deviceId;
    opt.textContent = c.label || `Camera ${i+1}`;
    selCam.appendChild(opt);
  });

  if([...selCam.options].some(o => o.value === prev)){ selCam.value = prev; return; }
  if([...selCam.options].some(o => o.value === saved)){ selCam.value = saved; return; }

  if(autoPickBack && lockBack.checked){
    const backOpt = [...selCam.options].find(o => isBackLabel(o.textContent));
    if(backOpt){ selCam.value = backOpt.value; return; }
  }
  if(selCam.options.length) selCam.selectedIndex = 0;
}
selCam.addEventListener('change', () => localStorage.setItem(LS.cam, selCam.value || ""));

// ===== ROI overlay =====
function setRoiBox(){
  const stage = roiEl.parentElement;
  const r = stage.getBoundingClientRect();
  roiEl.style.left = (ROI.x * r.width) + 'px';
  roiEl.style.top  = (ROI.y * r.height) + 'px';
  roiEl.style.width  = (ROI.w * r.width) + 'px';
  roiEl.style.height = (ROI.h * r.height) + 'px';
}
window.addEventListener('resize', setRoiBox);

// ===== start/stop =====
async function startCamera(){
  await listCams({preserve:true, autoPickBack:false});
  // permission warm-up
  try{
    const tmp = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: lockBack.checked ? "environment" : "user" } },
      audio: false
    });
    tmp.getTracks().forEach(t => t.stop());
  }catch(e){}

  await listCams({preserve:true, autoPickBack:true});
  const deviceId = selCam.value || undefined;

  stream = await navigator.mediaDevices.getUserMedia({
    video: {
      deviceId: deviceId ? { exact: deviceId } : undefined,
      facingMode: deviceId ? undefined : { ideal: lockBack.checked ? "environment" : "user" },
      width: { ideal: 1280 },
      height:{ ideal: 720 }
    },
    audio:false
  });

  video.srcObject = stream;
  await video.play();

  btnStart.disabled = true;
  btnStop.disabled  = false;

  overlay.width = video.videoWidth;
  overlay.height = video.videoHeight;

  setRoiBox();
  resetStabilizer();
  loop();
}
function stopCamera(){
  cancelAnimationFrame(rafId);
  rafId = null;
  if(stream){
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  video.pause();
  video.srcObject = null;

  btnStart.disabled = false;
  btnStop.disabled  = true;
  thrUsedEl.textContent = '—';
  outEl.textContent = '—';
  candLine.textContent = '候補: —';
  dbgEl.textContent = '';
  setLamp("off");
}
btnStart.onclick = async () => {
  try{ await startCamera(); }
  catch(e){ alert('カメラ開始失敗: ' + (e?.name ? `${e.name}: ${e.message}` : e.message)); }
};
btnStop.onclick = () => stopCamera();
selCam.onchange = async () => {
  localStorage.setItem(LS.cam, selCam.value || "");
  if(!stream) return;
  stopCamera();
  await new Promise(r => setTimeout(r, 200));
  btnStart.onclick();
};

// ===== image ops =====
function dilate3x3(src, w, h){
  const dst = new Uint8Array(w*h);
  for(let y=0; y<h; y++){
    for(let x=0; x<w; x++){
      let on = 0;
      for(let yy=Math.max(0,y-1); yy<=Math.min(h-1,y+1) && !on; yy++){
        const base = yy*w;
        for(let xx=Math.max(0,x-1); xx<=Math.min(w-1,x+1); xx++){
          if(src[base+xx]){ on=1; break; }
        }
      }
      dst[y*w+x] = on;
    }
  }
  return dst;
}

function otsuThresholdFromGray(gray){
  const hist = new Uint32Array(256);
  for(let i=0;i<gray.length;i++) hist[gray[i]]++;
  const total = gray.length;
  if(total === 0) return 128;

  let sum = 0;
  for(let t=0;t<256;t++) sum += t * hist[t];

  let sumB = 0;
  let wB = 0;
  let varMax = -1;
  let threshold = 128;

  for(let t=0;t<256;t++){
    wB += hist[t];
    if(wB === 0) continue;
    const wF = total - wB;
    if(wF === 0) break;

    sumB += t * hist[t];

    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;

    const varBetween = wB * wF * (mB - mF) * (mB - mF);
    if(varBetween > varMax){
      varMax = varBetween;
      threshold = t;
    }
  }
  return threshold;
}

// ===== blob bbox (thin '1' friendly) =====
function bestSegmentBySum(arr, thr){
  let best = {ok:false, a:0,b:0,sum:0};
  let a=-1, sum=0;
  for(let i=0;i<arr.length;i++){
    const on = arr[i] >= thr;
    if(on){
      if(a<0){ a=i; sum=0; }
      sum += arr[i];
    }else{
      if(a>=0){
        const b=i-1;
        if(sum > best.sum) best = {ok:true, a,b,sum};
        a=-1;
      }
    }
  }
  if(a>=0){
    const b=arr.length-1;
    if(sum > best.sum) best = {ok:true, a,b,sum};
  }
  return best;
}

function findDenseBlobBBox(bw, w, h){
  const col = new Uint32Array(w);
  const row = new Uint32Array(h);

  for(let y=0; y<h; y++){
    const base=y*w;
    let rs=0;
    for(let x=0; x<w; x++){
      const v = bw[base+x];
      col[x]+=v;
      rs += v;
    }
    row[y]=rs;
  }

  let colMax=0, rowMax=0;
  for(const v of col) if(v>colMax) colMax=v;
  for(const v of row) if(v>rowMax) rowMax=v;

  // ★細い「1」対策：閾値を下げる（0.06 / 0.10）
  const colThr = Math.max(2, Math.floor(colMax*0.06));
  const rowThr = Math.max(2, Math.floor(rowMax*0.10));

  const xSeg = bestSegmentBySum(col, colThr);
  const ySeg = bestSegmentBySum(row, rowThr);
  if(!xSeg.ok || !ySeg.ok) return {ok:false, x:0,y:0,w:w,h:h};

  // ★パディングも少し増やす
  const px = Math.max(1, Math.floor(w*0.03));
  const py = Math.max(1, Math.floor(h*0.05));
  const x1 = Math.max(0, xSeg.a - px);
  const x2 = Math.min(w-1, xSeg.b + px);
  const y1 = Math.max(0, ySeg.a - py);
  const y2 = Math.min(h-1, ySeg.b + py);

  const ww = x2-x1+1, hh = y2-y1+1;
  if(ww < Math.floor(w*0.18) || hh < Math.floor(h*0.30)) return {ok:false, x:0,y:0,w:w,h:h};
  return {ok:true, x:x1, y:y1, w:ww, h:hh};
}

// ===== 7seg sampling =====
function sampleWhiteRatio(bw,w,h,cx,cy,r){
  let white=0,total=0;
  const x1=Math.max(0,cx-r), x2=Math.min(w-1,cx+r);
  const y1=Math.max(0,cy-r), y2=Math.min(h-1,cy+r);
  for(let y=y1;y<=y2;y++){
    const base=y*w;
    for(let x=x1;x<=x2;x++){
      total++;
      if(bw[base+x]) white++;
    }
  }
  return total ? white/total : 0;
}

function detectDotBetween(bw, w, h, boxes){
  const real = boxes.filter(b=>!b.blank);
  if(real.length < 2) return null;

  for(let i=0; i<real.length-1; i++){
    const left = real[i];
    const right = real[i+1];
    const gapL = left.x + left.w;
    const gapR = right.x;
    const gapW = gapR - gapL;
    if(gapW <= 2) continue;

    const cx = Math.floor(gapL + gapW*0.50);
    const y1 = Math.floor(left.y + left.h*0.70);
    const y2 = Math.floor(left.y + left.h*0.95);
    const r = Math.max(1, Math.floor(Math.min(gapW, left.h)*0.10));

    let white=0,total=0;
    for(let y=Math.max(0,y1); y<=Math.min(h-1,y2); y++){
      const base=y*w;
      for(let x=Math.max(0,cx-r); x<=Math.min(w-1,cx+r); x++){
        total++;
        if(bw[base+x]) white++;
      }
    }
    const ratio = total ? white/total : 0;
    if(ratio >= 0.08) return i+1;
  }
  return null;
}

function recognizeByEqualSplit(bw,w,h,x0,y0,ww,hh,nDigits,decimalMode,segOnThr,debugBoxes){
  const digitW = ww / nDigits;
  const samples = { a:[0.50,0.18], b:[0.82,0.35], c:[0.82,0.72], d:[0.50,0.88], e:[0.18,0.72], f:[0.18,0.35], g:[0.50,0.53] };
  const map = {"1111110":"0","0110000":"1","1101101":"2","1111001":"3","0110011":"4","1011011":"5","1011111":"6","1110000":"7","1111111":"8","1111011":"9","0000000":""};

  let digits=[]; let confSum=0;
  for(let i=0;i<nDigits;i++){
    const dx = Math.floor(x0 + i*digitW);
    const dw = Math.max(3, Math.floor(digitW));
    const rad = Math.max(1, Math.floor(Math.min(dw,hh)*0.018));
    debugBoxes.push({x:dx,y:y0,w:dw,h:hh});

    let bits=""; let local=0;
    for(const k of ["a","b","c","d","e","f","g"]){
      const [rx,ry]=samples[k];
      const sx=Math.floor(dx + rx*dw);
      const sy=Math.floor(y0 + ry*hh);
      const ratio=sampleWhiteRatio(bw,w,h,sx,sy,rad);
      const on = ratio >= segOnThr;
      bits += on ? "1":"0";
      local += Math.min(1, Math.abs(ratio - segOnThr) / Math.max(0.18, (1-segOnThr)));
    }
    local/=7;
    const d = map[bits];
    digits.push(d !== undefined ? d : "");
    confSum += local;
  }

  // raw
  let raw = digits.join("");

  // decimal logic:
  // auto: dot検出に失敗したら「短すぎるraw」には last-fallback しない（8.8 事故対策）
  let s = raw;
  if(decimalMode==="last"){
    if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
  }else if(decimalMode==="auto"){
    const dotIdx = detectDotBetween(bw, w, h, debugBoxes.map(b=>({blank:false,...b})));
    if(dotIdx !== null){
      s = raw.slice(0, dotIdx) + "." + raw.slice(dotIdx);
      s = s.replace(/^\./,"");
    }else{
      // fallback: rawが3桁以上のときだけ xxx.x にする
      if(raw.length>=3) s = raw.slice(0,-1) + "." + raw.slice(-1);
    }
  }

  const ok = /^[0-9]+(\.[0-9]+)?$/.test(s);
  return {text: ok ? s : null, conf: confSum / nDigits, debug: ok ? "eqSplit" : "unmatched(eq)", debugBoxes};
}

function recognizeDigits(bw, w, h, nDigits, decimalMode, segOnThr, blob){
  const bx = blob?.ok ? blob.x : 0;
  const by = blob?.ok ? blob.y : 0;
  const bwid = blob?.ok ? blob.w : w;
  const bhgt = blob?.ok ? blob.h : h;

  const padX = Math.max(1, Math.floor(bwid*0.02));
  const padY = Math.max(1, Math.floor(bhgt*0.06));
  const x0 = bx + padX;
  const y0 = by + padY;
  const ww = Math.max(1, bwid - padX*2);
  const hh = Math.max(1, bhgt - padY*2);

  // col projection
  const col = new Uint32Array(ww);
  for(let y=y0; y<y0+hh; y++){
    const base=y*w;
    for(let x=0; x<ww; x++){
      col[x] += bw[base + (x0+x)];
    }
  }
  let colMax=0;
  for(const v of col) if(v>colMax) colMax=v;

  const cutThr = Math.max(1, Math.floor(colMax*0.10)); // ★さらに低め（細い1用）
  let segs=[];
  let a=-1;
  for(let x=0; x<ww; x++){
    const on = col[x] >= cutThr;
    if(on && a<0) a=x;
    if(!on && a>=0){ segs.push({a, b:x-1}); a=-1; }
  }
  if(a>=0) segs.push({a, b:ww-1});

  const minW = Math.max(1, Math.floor(ww*0.010)); // ★1%（さらに小さく）
  segs = segs.filter(s => (s.b-s.a+1) >= minW);

  const debugBoxes = [];

  if(segs.length < nDigits){
    return recognizeByEqualSplit(bw, w, h, x0, y0, ww, hh, nDigits, decimalMode, segOnThr, debugBoxes);
  }
  if(segs.length > nDigits){
    segs.sort((s1,s2)=> (s2.b-s2.a) - (s1.b-s1.a));
    segs = segs.slice(0, nDigits);
    segs.sort((s1,s2)=> s1.a - s2.a);
  }

  const boxes = segs.map(s => ({blank:false, x:x0+s.a, y:y0, w:(s.b-s.a+1), h:hh}));

  const samples = {
    a:[0.50,0.18], b:[0.82,0.35], c:[0.82,0.72],
    d:[0.50,0.88], e:[0.18,0.72], f:[0.18,0.35], g:[0.50,0.53]
  };
  const map = {
    "1111110":"0","0110000":"1","1101101":"2","1111001":"3","0110011":"4",
    "1011011":"5","1011111":"6","1110000":"7","1111111":"8","1111011":"9",
    "0000000":""
  };

  let digits=[]; let confSum=0;
  for(const b of boxes){
    debugBoxes.push({x:b.x, y:b.y, w:b.w, h:b.h});
    const dw = Math.max(3, b.w);
    const dh = Math.max(3, b.h);
    const rad = Math.max(1, Math.floor(Math.min(dw,dh)*0.018));

    let bits=""; let local=0;
    for(const k of ["a","b","c","d","e","f","g"]){
      const [rx,ry]=samples[k];
      const sx=Math.floor(b.x + rx*dw);
      const sy=Math.floor(b.y + ry*dh);
      const ratio = sampleWhiteRatio(bw, w, h, sx, sy, rad);
      const on = ratio >= segOnThr;
      bits += on ? "1":"0";
      local += Math.min(1, Math.abs(ratio - segOnThr) / Math.max(0.18, (1-segOnThr)));
    }
    local/=7;

    const d = (map[bits] !== undefined) ? map[bits] : "";
    digits.push(d);
    confSum += local;
  }

  const raw = digits.join("");
  let s = raw;

  if(decimalMode === "last"){
    if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
  }else if(decimalMode === "auto"){
    const dotIdx = detectDotBetween(bw, w, h, boxes);
    if(dotIdx !== null){
      s = raw.slice(0, dotIdx) + "." + raw.slice(dotIdx);
      s = s.replace(/^\./,"");
    }else{
      if(raw.length>=3) s = raw.slice(0,-1) + "." + raw.slice(-1);
    }
  }

  const ok = /^[0-9]+(\.[0-9]+)?$/.test(s);
  return {text: ok ? s : null, conf: confSum / Math.max(1, boxes.length), debug: ok ? "ok" : "unmatched", debugBoxes};
}

// ===== stabilizer =====
let lastCandidate = null;
let consec = 0;
let stableText = null;
let stableConf = 0;

function resetStabilizer(){
  lastCandidate = null;
  consec = 0;
  stableText = null;
  stableConf = 0;
  setLamp("off");
}

function setLamp(state){
  lampEl.classList.remove("green","yellow");
  if(state === "green") lampEl.classList.add("green");
  if(state === "yellow") lampEl.classList.add("yellow");
}

function toFixed1dpIfNeeded(text){
  if(!force1dpEl.checked) return text;
  if(!text) return text;
  if(text.includes(".")){
    // 小数2桁以上は丸めない（そのまま）
    const parts = text.split(".");
    if(parts[1].length === 1) return text;
    return text;
  }
  // 整数なら .0 を付ける
  return text + ".0";
}

function passesGate(text){
  if(!gateOnEl.checked) return true;
  if(!text) return false;

  const digitsOnly = text.replace(".","");
  const minDigits = parseInt(minDigitsEl.value || "3", 10);
  if(digitsOnly.length < minDigits) return false;

  const v = parseFloat(text);
  const minV = parseFloat(minValEl.value || "0");
  const maxV = parseFloat(maxValEl.value || "9999");
  if(Number.isNaN(v)) return false;
  if(v < minV || v > maxV) return false;

  return true;
}

btnCopy.onclick = async ()=>{
  const t = stableText || outEl.textContent;
  if(!t || t==="—") return;
  try{
    await navigator.clipboard.writeText(t);
    dbgEl.textContent = (dbgEl.textContent || "") + " | copied";
  }catch(_){
    prompt("コピーして使ってください:", t);
  }
};

// ===== main loop =====
let lastAnalyzeAt = 0;

function loop(){
  const now = performance.now();
  const interval = parseInt(anMsEl.value, 10);

  ctxO.clearRect(0,0,overlay.width,overlay.height);

  const rx = Math.floor(ROI.x * overlay.width);
  const ry = Math.floor(ROI.y * overlay.height);
  const rw = Math.floor(ROI.w * overlay.width);
  const rh = Math.floor(ROI.h * overlay.height);

  // ROI枠（赤）
  ctxO.strokeStyle = 'rgba(255,0,0,.95)';
  ctxO.lineWidth = 3;
  ctxO.strokeRect(rx+1, ry+1, rw-2, rh-2);

  if(now - lastAnalyzeAt < interval){
    rafId = requestAnimationFrame(loop);
    return;
  }
  lastAnalyzeAt = now;

  work.width = rw; work.height = rh;
  ctxW.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);

  const imageData = ctxW.getImageData(0,0,rw,rh);
  const data = imageData.data;

  const gray = new Uint8Array(rw*rh);
  for(let i=0, p=0; i<data.length; i+=4, p++){
    const r=data[i], g=data[i+1], b=data[i+2];
    gray[p] = (r*0.299 + g*0.587 + b*0.114) | 0;
  }

  let T = autoThrEl.checked ? otsuThresholdFromGray(gray) : 110;
  T = clamp(T + parseInt(thrOffEl.value,10), 0, 255);
  thrUsedEl.textContent = String(T);

  const inv = invertEl.checked;
  let bw = new Uint8Array(rw*rh);
  for(let p=0; p<gray.length; p++){
    const on = inv ? (gray[p] < T) : (gray[p] > T);
    bw[p] = on ? 1 : 0;
  }
  if(dilateEl.checked){
    bw = dilate3x3(bw, rw, rh);
  }

  // blob bbox（シアン）
  const blob = findDenseBlobBBox(bw, rw, rh);
  if(blob.ok){
    ctxO.strokeStyle = 'rgba(0,200,255,.95)';
    ctxO.lineWidth = 3;
    ctxO.strokeRect(rx + blob.x + 1, ry + blob.y + 1, blob.w - 2, blob.h - 2);
  }

  const nd = parseInt(digitsEl.value, 10);
  const decMode = decEl.value;
  const segThr = parseFloat(segThrEl.value);

  const res = recognizeDigits(bw, rw, rh, nd, decMode, segThr, blob);

  // digit boxes（黄）
  if(res.debugBoxes && res.debugBoxes.length){
    ctxO.strokeStyle = 'rgba(255,230,0,.95)';
    ctxO.lineWidth = 2;
    for(const b of res.debugBoxes){
      ctxO.strokeRect(rx + b.x, ry + b.y, b.w, b.h);
    }
  }

  // candidate
  let candidate = res.text; // string or null
  const conf = res.conf ?? 0;

  // normalize (force 1dp)
  if(candidate) candidate = toFixed1dpIfNeeded(candidate);

  // 候補表示
  candLine.textContent = `候補: ${candidate ?? "—"}  (conf=${conf.toFixed(2)} / ${res.debug})`;

  const needFrames = parseInt(needFramesEl.value, 10);
  const needConf = parseFloat(needConfEl.value);

  // acceptable = conf + gate
  const acceptable = (candidate !== null) && (conf >= needConf) && passesGate(candidate);

  if(!stabilizeEl.checked){
    if(acceptable){
      outEl.textContent = candidate;
      stableText = candidate;
      stableConf = conf;
      setLamp("green");
    }else{
      if(!holdEl.checked) outEl.textContent = "—";
      setLamp("yellow");
    }
  }else{
    if(acceptable){
      if(candidate === lastCandidate){
        consec++;
      }else{
        lastCandidate = candidate;
        consec = 1;
      }

      if(consec >= needFrames){
        stableText = candidate;
        stableConf = conf;
        outEl.textContent = stableText;
        setLamp("green");
      }else{
        if(!holdEl.checked) outEl.textContent = "—";
        else if(stableText) outEl.textContent = stableText;
        setLamp("yellow");
      }
    }else{
      lastCandidate = null;
      consec = 0;

      if(!holdEl.checked) outEl.textContent = "—";
      else if(stableText) outEl.textContent = stableText;

      setLamp("yellow");
    }
  }

  const camLabel = selCam.selectedOptions?.[0]?.textContent || "";
  dbgEl.textContent =
    `mode=${stabilizeEl.checked? "stabilize":"raw"} consec=${consec}/${needFrames} conf=${conf.toFixed(2)} needConf=${needConf.toFixed(2)} gate=${gateOnEl.checked?1:0} ok=${acceptable?1:0} ` +
    `| T=${T} inv=${inv?1:0} dil=${dilateEl.checked?1:0} segThr=${segThr.toFixed(2)} | cam="${camLabel}"`;

  rafId = requestAnimationFrame(loop);
}

// init
navigator.mediaDevices?.addEventListener?.('devicechange', () => listCams({preserve:true, autoPickBack:true}));
listCams({preserve:true, autoPickBack:true}).catch(()=>{});
setRoiBox();
syncLabels();

// camera event
function isBackLabel(label){
  if(!label) return false;
  return /(back|rear|environment|背面|リア|後ろ)/i.test(label);
}
</script>
</body>
</html>
