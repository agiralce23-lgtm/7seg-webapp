<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>7セグ認識 Webアプリ v5（自動しきい値 / iPhone向け）</title>
<style>
  body { font-family: system-ui, -apple-system, sans-serif; margin: 0; background:#111; color:#eee; }
  .wrap { display:flex; flex-direction:column; gap:10px; padding:10px; max-width:1100px; margin:0 auto; }
  .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  button, select, input { font-size:16px; padding:8px 10px; }
  .stage { position:relative; width:100%; aspect-ratio: 16/9; background:#000; overflow:hidden; border-radius:10px; }
  /* ★重要：containで「見た目」と「実際の切り出し」を一致させる */
  video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; }
  .roi {
    position:absolute;
    border:2px solid rgba(255,0,0,.9);
    box-shadow: 0 0 0 9999px rgba(0,0,0,.35);
    border-radius:8px;
    pointer-events:none;
  }
  .panel { background:#1b1b1b; padding:10px; border-radius:10px; }
  .k { color:#9ad; }
  .big { font-size:30px; font-weight:800; letter-spacing: .5px; }
  .hint { color:#bbb; font-size:13px; line-height:1.45; }
  .grid { display:grid; grid-template-columns: 1.1fr 0.9fr; gap:10px; }
  @media (max-width: 820px){ .grid { grid-template-columns: 1fr; } }
  .chip { display:flex; align-items:center; gap:6px; background:#222; padding:6px 8px; border-radius:999px; }
  details { background:#151515; border-radius:10px; padding:8px 10px; }
  details summary { cursor:pointer; }
  .kv { display:grid; grid-template-columns: 110px 1fr 70px; gap:8px; align-items:center; margin-top:8px;}
  .kv label{ color:#bbb; font-size:13px;}
  .kv input[type=range]{ width:100%; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <button id="btnStart">カメラ開始</button>
    <button id="btnStop" disabled>停止</button>

    <label>カメラ</label>
    <select id="selCam"></select>

    <span class="chip"><input id="lockBack" type="checkbox" checked />背面固定</span>
    <span class="chip"><input id="invert" type="checkbox" checked />反転（黒い数字用）</span>
    <span class="chip"><input id="dilate" type="checkbox" />太らせる</span>

    <span class="chip"><input id="autoThr" type="checkbox" checked />自動2値化（Otsu）</span>
    <label>オフセット</label>
    <input id="thrOff" type="range" min="-80" max="80" value="0" />
    <span id="thrOffVal">0</span>

    <label>使用しきい値</label>
    <span id="thrUsed" class="mono">—</span>

    <label>桁</label>
    <select id="digits">
      <option value="4" selected>4桁</option>
      <option value="5">5桁</option>
    </select>

    <label>小数点</label>
    <select id="decimal">
      <option value="auto" selected>自動（ドット検出）</option>
      <option value="last">最後の1桁前（xxx.x）</option>
      <option value="none">なし</option>
    </select>

    <label>セグ判定</label>
    <input id="segThr" type="range" min="0.18" max="0.65" step="0.01" value="0.34" />
    <span id="segThrVal">0.34</span>
  </div>

  <details>
    <summary>ROI調整（1回合わせたら保存されます）</summary>
    <div class="kv"><label>X</label><input id="roiX" type="range" min="0" max="1" step="0.01"><span id="roiXv"></span></div>
    <div class="kv"><label>Y</label><input id="roiY" type="range" min="0" max="1" step="0.01"><span id="roiYv"></span></div>
    <div class="kv"><label>W</label><input id="roiW" type="range" min="0.05" max="1" step="0.01"><span id="roiWv"></span></div>
    <div class="kv"><label>H</label><input id="roiH" type="range" min="0.05" max="1" step="0.01"><span id="roiHv"></span></div>
    <div class="row" style="margin-top:8px;">
      <button id="btnRoiReset" type="button">ROIリセット（この機種向け）</button>
    </div>
    <div class="hint" style="margin-top:6px;">
      赤枠＝ROI、シアン枠＝検出された「数字の塊」、黄色枠＝推定した各桁領域。<br>
      ※いまは <b>自動2値化</b> が入っているので、2値化スライダー調整は基本不要です。
    </div>
  </details>

  <div class="grid">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
      <div id="roi" class="roi"></div>
    </div>

    <div class="panel">
      <div><span class="k">認識結果</span></div>
      <div id="out" class="big">—</div>
      <div class="hint mono" id="dbg"></div>
      <hr style="border:0;border-top:1px solid #333;margin:10px 0;">
      <div class="hint">
        <div>「2値化が難しい」対策として、ROI内の明暗から自動でしきい値を決めます（<b>Otsu</b>）。</div>
        <div>うまくいかない時だけ <b>オフセット</b> を ±10〜±30 程度動かしてください。</div>
        <div>桁が「1」を含むと細くて消えやすいので、桁分割は <b>等分フォールバック</b> を入れてあります。</div>
      </div>
    </div>
  </div>

  <canvas id="work" style="display:none;"></canvas>
</div>

<script>
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const work = document.getElementById('work');
const ctxO = overlay.getContext('2d', { willReadFrequently:true });
const ctxW = work.getContext('2d', { willReadFrequently:true });

const btnStart = document.getElementById('btnStart');
const btnStop  = document.getElementById('btnStop');
const selCam   = document.getElementById('selCam');

const lockBack = document.getElementById('lockBack');
const invertEl = document.getElementById('invert');
const dilateEl = document.getElementById('dilate');

const autoThrEl = document.getElementById('autoThr');
const thrOffEl = document.getElementById('thrOff');
const thrOffVal = document.getElementById('thrOffVal');
const thrUsedEl = document.getElementById('thrUsed');

const digitsEl = document.getElementById('digits');
const decEl    = document.getElementById('decimal');
const segThrEl = document.getElementById('segThr');
const segThrVal= document.getElementById('segThrVal');

const outEl    = document.getElementById('out');
const dbgEl    = document.getElementById('dbg');
const roiEl    = document.getElementById('roi');

const roiX = document.getElementById('roiX');
const roiY = document.getElementById('roiY');
const roiW = document.getElementById('roiW');
const roiH = document.getElementById('roiH');
const roiXv = document.getElementById('roiXv');
const roiYv = document.getElementById('roiYv');
const roiWv = document.getElementById('roiWv');
const roiHv = document.getElementById('roiHv');
const btnRoiReset = document.getElementById('btnRoiReset');

let stream = null;
let rafId = null;

// ===== storage =====
const LS = {
  cam: "sevenseg_cam_deviceid",
  lock: "sevenseg_lockback",
  inv: "sevenseg_invert",
  dil: "sevenseg_dilate",
  segthr: "sevenseg_segthr",
  auto: "sevenseg_autothr",
  off: "sevenseg_throff",
  roi: "sevenseg_roi_v5",
};

const defaultRoi = { x: 0.18, y: 0.44, w: 0.64, h: 0.18 }; // 表示窓寄り
let ROI = loadROI();

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function clamp01(v){ return clamp(v, 0, 1); }

function loadROI(){
  try{
    const s = localStorage.getItem(LS.roi);
    if(!s) return {...defaultRoi};
    const o = JSON.parse(s);
    return { x: clamp01(+o.x), y: clamp01(+o.y), w: clamp01(+o.w), h: clamp01(+o.h) };
  }catch(_){ return {...defaultRoi}; }
}
function saveROI(){ localStorage.setItem(LS.roi, JSON.stringify(ROI)); }

lockBack.checked = (localStorage.getItem(LS.lock) ?? "1") === "1";
invertEl.checked = (localStorage.getItem(LS.inv) ?? "1") === "1";
dilateEl.checked = (localStorage.getItem(LS.dil) ?? "0") === "1";
segThrEl.value = (localStorage.getItem(LS.segthr) ?? "0.34");
autoThrEl.checked = (localStorage.getItem(LS.auto) ?? "1") === "1";
thrOffEl.value = (localStorage.getItem(LS.off) ?? "0");

function syncLabels(){
  segThrVal.textContent = Number(segThrEl.value).toFixed(2);
  thrOffVal.textContent = String(thrOffEl.value);

  roiX.value = ROI.x; roiY.value = ROI.y; roiW.value = ROI.w; roiH.value = ROI.h;
  roiXv.textContent = ROI.x.toFixed(2);
  roiYv.textContent = ROI.y.toFixed(2);
  roiWv.textContent = ROI.w.toFixed(2);
  roiHv.textContent = ROI.h.toFixed(2);
}
syncLabels();

function bindRoiSlider(sl, key){
  sl.addEventListener('input', ()=>{
    ROI[key] = clamp01(parseFloat(sl.value));
    if(key==="w") ROI.w = Math.max(0.05, ROI.w);
    if(key==="h") ROI.h = Math.max(0.05, ROI.h);
    ROI.x = clamp01(Math.min(ROI.x, 1-ROI.w));
    ROI.y = clamp01(Math.min(ROI.y, 1-ROI.h));
    syncLabels();
    saveROI();
    setRoiBox();
  });
}
bindRoiSlider(roiX,"x");
bindRoiSlider(roiY,"y");
bindRoiSlider(roiW,"w");
bindRoiSlider(roiH,"h");

btnRoiReset.onclick = ()=>{
  ROI = {...defaultRoi};
  saveROI();
  syncLabels();
  setRoiBox();
};

lockBack.addEventListener('change', ()=> localStorage.setItem(LS.lock, lockBack.checked ? "1":"0"));
invertEl.addEventListener('change', ()=> localStorage.setItem(LS.inv, invertEl.checked ? "1":"0"));
dilateEl.addEventListener('change', ()=> localStorage.setItem(LS.dil, dilateEl.checked ? "1":"0"));
segThrEl.addEventListener('input', ()=> { localStorage.setItem(LS.segthr, segThrEl.value); syncLabels(); });

autoThrEl.addEventListener('change', ()=> localStorage.setItem(LS.auto, autoThrEl.checked ? "1":"0"));
thrOffEl.addEventListener('input', ()=> { localStorage.setItem(LS.off, thrOffEl.value); syncLabels(); });

// ===== camera selection =====
function isBackLabel(label){
  if(!label) return false;
  return /(back|rear|environment|背面|リア|後ろ)/i.test(label);
}
async function listCams({preserve=true, autoPickBack=true} = {}){
  const prev = preserve ? selCam.value : "";
  const saved = localStorage.getItem(LS.cam) || "";
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d => d.kind === 'videoinput');

  selCam.innerHTML = '';
  cams.forEach((c, i) => {
    const opt = document.createElement('option');
    opt.value = c.deviceId;
    opt.textContent = c.label || `Camera ${i+1}`;
    selCam.appendChild(opt);
  });

  if([...selCam.options].some(o => o.value === prev)){ selCam.value = prev; return; }
  if([...selCam.options].some(o => o.value === saved)){ selCam.value = saved; return; }

  if(autoPickBack && lockBack.checked){
    const backOpt = [...selCam.options].find(o => isBackLabel(o.textContent));
    if(backOpt){ selCam.value = backOpt.value; return; }
  }
  if(selCam.options.length) selCam.selectedIndex = 0;
}
selCam.addEventListener('change', () => localStorage.setItem(LS.cam, selCam.value || ""));

// ===== ROI overlay =====
function setRoiBox(){
  const stage = roiEl.parentElement;
  const r = stage.getBoundingClientRect();
  roiEl.style.left = (ROI.x * r.width) + 'px';
  roiEl.style.top  = (ROI.y * r.height) + 'px';
  roiEl.style.width  = (ROI.w * r.width) + 'px';
  roiEl.style.height = (ROI.h * r.height) + 'px';
}
window.addEventListener('resize', setRoiBox);

// ===== start/stop =====
async function startCamera(){
  await listCams({preserve:true, autoPickBack:false});
  // permission warm-up
  try{
    const tmp = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: lockBack.checked ? "environment" : "user" } },
      audio: false
    });
    tmp.getTracks().forEach(t => t.stop());
  }catch(e){}

  await listCams({preserve:true, autoPickBack:true});
  const deviceId = selCam.value || undefined;

  stream = await navigator.mediaDevices.getUserMedia({
    video: {
      deviceId: deviceId ? { exact: deviceId } : undefined,
      facingMode: deviceId ? undefined : { ideal: lockBack.checked ? "environment" : "user" },
      width: { ideal: 1280 },
      height:{ ideal: 720 }
    },
    audio:false
  });

  video.srcObject = stream;
  await video.play();

  btnStart.disabled = true;
  btnStop.disabled  = false;

  overlay.width = video.videoWidth;
  overlay.height = video.videoHeight;

  setRoiBox();
  loop();
}
function stopCamera(){
  cancelAnimationFrame(rafId);
  rafId = null;
  if(stream){
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  video.pause();
  video.srcObject = null;

  btnStart.disabled = false;
  btnStop.disabled  = true;
  outEl.textContent = '—';
  dbgEl.textContent = '';
  thrUsedEl.textContent = '—';
}
btnStart.onclick = async () => {
  try{ await startCamera(); }
  catch(e){ alert('カメラ開始失敗: ' + (e?.name ? `${e.name}: ${e.message}` : e.message)); }
};
btnStop.onclick = () => stopCamera();
selCam.onchange = async () => {
  localStorage.setItem(LS.cam, selCam.value || "");
  if(!stream) return;
  stopCamera();
  await new Promise(r => setTimeout(r, 200));
  btnStart.onclick();
};

// ===== image ops =====
function dilate3x3(src, w, h){
  const dst = new Uint8Array(w*h);
  for(let y=0; y<h; y++){
    for(let x=0; x<w; x++){
      let on = 0;
      for(let yy=Math.max(0,y-1); yy<=Math.min(h-1,y+1) && !on; yy++){
        const base = yy*w;
        for(let xx=Math.max(0,x-1); xx<=Math.min(w-1,x+1); xx++){
          if(src[base+xx]){ on=1; break; }
        }
      }
      dst[y*w+x] = on;
    }
  }
  return dst;
}

function otsuThresholdFromGray(gray){
  // gray: Uint8Array
  const hist = new Uint32Array(256);
  for(let i=0;i<gray.length;i++) hist[gray[i]]++;
  const total = gray.length;
  if(total === 0) return 128;

  let sum = 0;
  for(let t=0;t<256;t++) sum += t * hist[t];

  let sumB = 0;
  let wB = 0;
  let varMax = -1;
  let threshold = 128;

  for(let t=0;t<256;t++){
    wB += hist[t];
    if(wB === 0) continue;
    const wF = total - wB;
    if(wF === 0) break;

    sumB += t * hist[t];

    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;

    const varBetween = wB * wF * (mB - mF) * (mB - mF);
    if(varBetween > varMax){
      varMax = varBetween;
      threshold = t;
    }
  }
  return threshold;
}

// ===== blob bbox from bw =====
function bestSegmentBySum(arr, thr){
  let best = {ok:false, a:0,b:0,sum:0};
  let a=-1, sum=0;
  for(let i=0;i<arr.length;i++){
    const on = arr[i] >= thr;
    if(on){
      if(a<0){ a=i; sum=0; }
      sum += arr[i];
    }else{
      if(a>=0){
        const b=i-1;
        if(sum > best.sum) best = {ok:true, a,b,sum};
        a=-1;
      }
    }
  }
  if(a>=0){
    const b=arr.length-1;
    if(sum > best.sum) best = {ok:true, a,b,sum};
  }
  return best;
}

function findDenseBlobBBox(bw, w, h){
  const col = new Uint32Array(w);
  const row = new Uint32Array(h);

  for(let y=0; y<h; y++){
    const base=y*w;
    let rs=0;
    for(let x=0; x<w; x++){
      const v = bw[base+x];
      col[x]+=v;
      rs += v;
    }
    row[y]=rs;
  }

  let colMax=0, rowMax=0;
  for(const v of col) if(v>colMax) colMax=v;
  for(const v of row) if(v>rowMax) rowMax=v;

  const colThr = Math.max(4, Math.floor(colMax*0.15));
  const rowThr = Math.max(4, Math.floor(rowMax*0.15));

  const xSeg = bestSegmentBySum(col, colThr);
  const ySeg = bestSegmentBySum(row, rowThr);
  if(!xSeg.ok || !ySeg.ok) return {ok:false, x:0,y:0,w:w,h:h};

  const px = Math.max(1, Math.floor(w*0.01));
  const py = Math.max(1, Math.floor(h*0.03));
  const x1 = Math.max(0, xSeg.a - px);
  const x2 = Math.min(w-1, xSeg.b + px);
  const y1 = Math.max(0, ySeg.a - py);
  const y2 = Math.min(h-1, ySeg.b + py);

  const ww = x2-x1+1, hh = y2-y1+1;
  if(ww < Math.floor(w*0.20) || hh < Math.floor(h*0.35)) return {ok:false, x:0,y:0,w:w,h:h};
  return {ok:true, x:x1, y:y1, w:ww, h:hh};
}

// ===== 7seg sampling =====
function sampleWhiteRatio(bw,w,h,cx,cy,r){
  let white=0,total=0;
  const x1=Math.max(0,cx-r), x2=Math.min(w-1,cx+r);
  const y1=Math.max(0,cy-r), y2=Math.min(h-1,cy+r);
  for(let y=y1;y<=y2;y++){
    const base=y*w;
    for(let x=x1;x<=x2;x++){
      total++;
      if(bw[base+x]) white++;
    }
  }
  return total ? white/total : 0;
}

function detectDotBetween(bw, w, h, boxes){
  const real = boxes.filter(b=>!b.blank);
  if(real.length < 2) return null;

  for(let i=0; i<real.length-1; i++){
    const left = real[i];
    const right = real[i+1];
    const gapL = left.x + left.w;
    const gapR = right.x;
    const gapW = gapR - gapL;
    if(gapW <= 2) continue;

    const cx = Math.floor(gapL + gapW*0.50);
    const y1 = Math.floor(left.y + left.h*0.70);
    const y2 = Math.floor(left.y + left.h*0.95);
    const r = Math.max(1, Math.floor(Math.min(gapW, left.h)*0.10));

    let white=0,total=0;
    for(let y=Math.max(0,y1); y<=Math.min(h-1,y2); y++){
      const base=y*w;
      for(let x=Math.max(0,cx-r); x<=Math.min(w-1,cx+r); x++){
        total++;
        if(bw[base+x]) white++;
      }
    }
    const ratio = total ? white/total : 0;
    if(ratio >= 0.08) return i+1;
  }
  return null;
}

function recognizeByEqualSplit(bw,w,h,x0,y0,ww,hh,nDigits,decimalMode,segOnThr,debugBoxes){
  const digitW = ww / nDigits;
  const samples = { a:[0.50,0.18], b:[0.82,0.35], c:[0.82,0.72], d:[0.50,0.88], e:[0.18,0.72], f:[0.18,0.35], g:[0.50,0.53] };
  const map = {"1111110":"0","0110000":"1","1101101":"2","1111001":"3","0110011":"4","1011011":"5","1011111":"6","1110000":"7","1111111":"8","1111011":"9","0000000":""};
  let digits=[]; let confSum=0;
  for(let i=0;i<nDigits;i++){
    const dx = Math.floor(x0 + i*digitW);
    const dw = Math.max(3, Math.floor(digitW));
    const rad = Math.max(1, Math.floor(Math.min(dw,hh)*0.018));
    debugBoxes.push({x:dx,y:y0,w:dw,h:hh});
    let bits=""; let local=0;
    for(const k of ["a","b","c","d","e","f","g"]){
      const [rx,ry]=samples[k];
      const sx=Math.floor(dx + rx*dw);
      const sy=Math.floor(y0 + ry*hh);
      const ratio=sampleWhiteRatio(bw,w,h,sx,sy,rad);
      const on = ratio >= segOnThr;
      bits += on ? "1":"0";
      local += Math.min(1, Math.abs(ratio - segOnThr) / Math.max(0.18, (1-segOnThr)));
    }
    local/=7;
    digits.push(map[bits] ?? "?");
    confSum += local;
  }

  // cleanup
  if(digits.some(d=>d==="?")) digits = digits.map(d=> d==="?" ? "" : d);

  let s = digits.join("");
  if(decimalMode==="last"){
    if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
  }else if(decimalMode==="auto"){
    const dotIdx = detectDotBetween(bw, w, h, debugBoxes.map(b=>({blank:false,...b})));
    if(dotIdx !== null){
      const raw = digits.join("");
      s = raw.slice(0, dotIdx) + "." + raw.slice(dotIdx);
      s = s.replace(/^\./,"");
    }else{
      if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
    }
  }

  if(!/^[0-9]+(\.[0-9]+)?$/.test(s)) return {text:null, debug:`unmatched(eq): ${digits.join("")}`, debugBoxes};
  return {text:s, debug:`eqSplit conf=${(confSum/nDigits).toFixed(2)}`, debugBoxes};
}

function recognizeDigits(bw, w, h, nDigits, decimalMode, segOnThr, blob){
  const bx = blob?.ok ? blob.x : 0;
  const by = blob?.ok ? blob.y : 0;
  const bwid = blob?.ok ? blob.w : w;
  const bhgt = blob?.ok ? blob.h : h;

  const padX = Math.max(1, Math.floor(bwid*0.02));
  const padY = Math.max(1, Math.floor(bhgt*0.06));
  const x0 = bx + padX;
  const y0 = by + padY;
  const ww = Math.max(1, bwid - padX*2);
  const hh = Math.max(1, bhgt - padY*2);

  // col projection
  const col = new Uint32Array(ww);
  for(let y=y0; y<y0+hh; y++){
    const base=y*w;
    for(let x=0; x<ww; x++){
      col[x] += bw[base + (x0+x)];
    }
  }
  let colMax=0;
  for(const v of col) if(v>colMax) colMax=v;

  // ★薄い「1」を拾うため cutThr を少し下げる
  const cutThr = Math.max(2, Math.floor(colMax*0.12));

  let segs=[];
  let a=-1;
  for(let x=0; x<ww; x++){
    const on = col[x] >= cutThr;
    if(on && a<0) a=x;
    if(!on && a>=0){ segs.push({a, b:x-1}); a=-1; }
  }
  if(a>=0) segs.push({a, b:ww-1});

  // ★細い桁(1)を落としにくいよう minW を小さめに
  const minW = Math.max(1, Math.floor(ww*0.012)); // 1.2%
  segs = segs.filter(s => (s.b-s.a+1) >= minW);

  const debugBoxes = [];

  // ★桁が足りない時は「空白埋め」ではなく等分にフォールバック（ここが 4.5 問題の根治）
  if(segs.length < nDigits){
    return recognizeByEqualSplit(bw, w, h, x0, y0, ww, hh, nDigits, decimalMode, segOnThr, debugBoxes);
  }

  if(segs.length > nDigits){
    segs.sort((s1,s2)=> (s2.b-s2.a) - (s1.b-s1.a));
    segs = segs.slice(0, nDigits);
    segs.sort((s1,s2)=> s1.a - s2.a);
  }

  const boxes = segs.map(s => ({blank:false, x:x0+s.a, y:y0, w:(s.b-s.a+1), h:hh}));

  const samples = {
    a:[0.50,0.18], b:[0.82,0.35], c:[0.82,0.72],
    d:[0.50,0.88], e:[0.18,0.72], f:[0.18,0.35], g:[0.50,0.53]
  };
  const map = {
    "1111110":"0","0110000":"1","1101101":"2","1111001":"3","0110011":"4",
    "1011011":"5","1011111":"6","1110000":"7","1111111":"8","1111011":"9",
    "0000000":""
  };

  let digits=[]; let confSum=0;
  for(const b of boxes){
    debugBoxes.push({x:b.x, y:b.y, w:b.w, h:b.h});
    const dw = Math.max(3, b.w);
    const dh = Math.max(3, b.h);
    const rad = Math.max(1, Math.floor(Math.min(dw,dh)*0.018));

    let bits=""; let local=0;
    for(const k of ["a","b","c","d","e","f","g"]){
      const [rx,ry]=samples[k];
      const sx=Math.floor(b.x + rx*dw);
      const sy=Math.floor(b.y + ry*dh);
      const ratio = sampleWhiteRatio(bw, w, h, sx, sy, rad);
      const on = ratio >= segOnThr;
      bits += on ? "1":"0";
      local += Math.min(1, Math.abs(ratio - segOnThr) / Math.max(0.18, (1-segOnThr)));
    }
    local/=7;

    const d = (map[bits] !== undefined) ? map[bits] : "?";
    digits.push(d==="?"? "" : d);
    confSum += local;
  }

  let s = digits.join("");

  if(decimalMode === "last"){
    if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
  }else if(decimalMode === "auto"){
    const dotIdx = detectDotBetween(bw, w, h, boxes);
    if(dotIdx !== null){
      const raw = digits.join("");
      s = raw.slice(0, dotIdx) + "." + raw.slice(dotIdx);
      s = s.replace(/^\./,"");
    }else{
      if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
    }
  }

  if(!/^[0-9]+(\.[0-9]+)?$/.test(s)){
    return {text:null, debug:`unmatched: ${digits.join("")}`, debugBoxes};
  }

  const conf = confSum / Math.max(1, boxes.length);
  return {text:s, debug:`conf=${conf.toFixed(2)} segThr=${segOnThr.toFixed(2)}`, debugBoxes};
}

// ===== main loop =====
function loop(){
  ctxO.clearRect(0,0,overlay.width,overlay.height);

  const rx = Math.floor(ROI.x * overlay.width);
  const ry = Math.floor(ROI.y * overlay.height);
  const rw = Math.floor(ROI.w * overlay.width);
  const rh = Math.floor(ROI.h * overlay.height);

  work.width = rw; work.height = rh;
  ctxW.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);

  const imageData = ctxW.getImageData(0,0,rw,rh);
  const data = imageData.data;

  // gray buffer
  const gray = new Uint8Array(rw*rh);
  for(let i=0, p=0; i<data.length; i+=4, p++){
    const r=data[i], g=data[i+1], b=data[i+2];
    gray[p] = (r*0.299 + g*0.587 + b*0.114) | 0;
  }

  let T;
  if(autoThrEl.checked){
    T = otsuThresholdFromGray(gray);
  }else{
    // 手動にしたい時は、オフセットを0にしてもOK
    T = 110;
  }
  T = clamp(T + parseInt(thrOffEl.value,10), 0, 255);
  thrUsedEl.textContent = String(T);

  const inv = invertEl.checked;

  let bw = new Uint8Array(rw*rh);
  for(let p=0; p<gray.length; p++){
    const on = inv ? (gray[p] < T) : (gray[p] > T);
    bw[p] = on ? 1 : 0;
  }

  if(dilateEl.checked){
    bw = dilate3x3(bw, rw, rh);
  }

  // ROI枠（赤）
  ctxO.strokeStyle = 'rgba(255,0,0,.95)';
  ctxO.lineWidth = 3;
  ctxO.strokeRect(rx+1, ry+1, rw-2, rh-2);

  // blob bbox（シアン）
  const blob = findDenseBlobBBox(bw, rw, rh);
  if(blob.ok){
    ctxO.strokeStyle = 'rgba(0,200,255,.95)';
    ctxO.lineWidth = 3;
    ctxO.strokeRect(rx + blob.x + 1, ry + blob.y + 1, blob.w - 2, blob.h - 2);
  }

  const nd = parseInt(digitsEl.value, 10);
  const decMode = decEl.value;
  const segThr = parseFloat(segThrEl.value);

  const res = recognizeDigits(bw, rw, rh, nd, decMode, segThr, blob);

  // digit boxes（黄）
  if(res.debugBoxes && res.debugBoxes.length){
    ctxO.strokeStyle = 'rgba(255,230,0,.95)';
    ctxO.lineWidth = 2;
    for(const b of res.debugBoxes){
      ctxO.strokeRect(rx + b.x, ry + b.y, b.w, b.h);
    }
  }

  const camLabel = selCam.selectedOptions?.[0]?.textContent || "";
  if(res.text){
    outEl.textContent = res.text;
    dbgEl.textContent = `${res.debug} | T=${T} inv=${inv?1:0} dil=${dilateEl.checked?1:0} cam="${camLabel}"`;
  }else{
    outEl.textContent = '—';
    dbgEl.textContent = `${res.debug || "no match"} | T=${T} inv=${inv?1:0} dil=${dilateEl.checked?1:0} cam="${camLabel}"`;
  }

  rafId = requestAnimationFrame(loop);
}

// init
navigator.mediaDevices?.addEventListener?.('devicechange', () => listCams({preserve:true, autoPickBack:true}));
listCams({preserve:true, autoPickBack:true}).catch(()=>{});
setRoiBox();
syncLabels();
</script>
</body>
</html>
