<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>7セグ認識 Webアプリ（ROI固定 / iPhone向け改善）</title>
<style>
  body { font-family: system-ui, -apple-system, sans-serif; margin: 0; background:#111; color:#eee; }
  .wrap { display:flex; flex-direction:column; gap:10px; padding:10px; max-width:980px; margin:0 auto; }
  .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  button, select, input { font-size:16px; padding:8px 10px; }
  .stage { position:relative; width:100%; aspect-ratio: 16/9; background:#000; overflow:hidden; border-radius:10px; }
  video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
  .roi {
    position:absolute;
    border:2px solid rgba(255,0,0,.9);
    box-shadow: 0 0 0 9999px rgba(0,0,0,.35);
    border-radius:6px;
    pointer-events:none;
  }
  .panel { background:#1b1b1b; padding:10px; border-radius:10px; }
  .k { color:#9ad; }
  .big { font-size:28px; font-weight:700; letter-spacing: .5px; }
  .hint { color:#bbb; font-size:13px; line-height:1.4; }
  .grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  @media (max-width: 700px){ .grid { grid-template-columns: 1fr; } }
  .chip { display:flex; align-items:center; gap:6px; background:#222; padding:6px 8px; border-radius:999px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <button id="btnStart">カメラ開始</button>
    <button id="btnStop" disabled>停止</button>

    <label>カメラ</label>
    <select id="selCam"></select>

    <span class="chip"><input id="lockBack" type="checkbox" checked />背面固定</span>
    <span class="chip"><input id="invert" type="checkbox" checked />反転（黒い数字用）</span>
    <span class="chip"><input id="autoTrim" type="checkbox" checked />自動トリム（数字だけ切り出し）</span>

    <label>2値化</label>
    <input id="thr" type="range" min="0" max="255" value="140" />
    <span id="thrVal">140</span>

    <label>桁</label>
    <select id="digits">
      <option value="4" selected>4桁</option>
      <option value="5">5桁</option>
    </select>

    <label>小数点</label>
    <select id="decimal">
      <option value="none">なし</option>
      <option value="last" selected>最後の1桁前（xxx.x）</option>
    </select>

    <label>セグ判定</label>
    <input id="segThr" type="range" min="0.20" max="0.75" step="0.01" value="0.38" />
    <span id="segThrVal">0.38</span>
  </div>

  <div class="grid">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
      <div id="roi" class="roi"></div>
    </div>

    <div class="panel">
      <div><span class="k">認識結果</span></div>
      <div id="out" class="big">—</div>
      <div class="hint" id="dbg"></div>
      <hr style="border:0;border-top:1px solid #333;margin:10px 0;">
      <div class="hint">
        <div>この体重計は「明るい背景に黒い数字」なので <b>反転ON</b> が必須です。</div>
        <div>数字が中央に寄っているので <b>自動トリムON</b> で数字部分だけを横方向に切り出してから桁分割します（緑枠）。</div>
        <div>まだ合わない時は「セグ判定」を 0.33〜0.45 あたりで調整してください。</div>
      </div>
    </div>
  </div>

  <canvas id="work" style="display:none;"></canvas>
</div>

<script>
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const work = document.getElementById('work');
const ctxO = overlay.getContext('2d', { willReadFrequently:true });
const ctxW = work.getContext('2d', { willReadFrequently:true });

const btnStart = document.getElementById('btnStart');
const btnStop  = document.getElementById('btnStop');
const selCam   = document.getElementById('selCam');
const lockBack = document.getElementById('lockBack');
const invertEl = document.getElementById('invert');
const autoTrimEl = document.getElementById('autoTrim');
const thr      = document.getElementById('thr');
const thrVal   = document.getElementById('thrVal');
const digitsEl = document.getElementById('digits');
const decEl    = document.getElementById('decimal');
const segThrEl = document.getElementById('segThr');
const segThrVal= document.getElementById('segThrVal');
const outEl    = document.getElementById('out');
const dbgEl    = document.getElementById('dbg');
const roiEl    = document.getElementById('roi');

let stream = null;
let rafId = null;

// ROI（画面比率で固定）
const ROI = { x: 0.18, y: 0.38, w: 0.64, h: 0.24 }; // 0..1

const LS = {
  cam: "sevenseg_cam_deviceid",
  lock: "sevenseg_lockback",
  inv: "sevenseg_invert",
  trim: "sevenseg_trim",
  thr: "sevenseg_thr",
  segthr: "sevenseg_segthr",
};

lockBack.checked = (localStorage.getItem(LS.lock) ?? "1") === "1";
invertEl.checked = (localStorage.getItem(LS.inv) ?? "1") === "1";
autoTrimEl.checked = (localStorage.getItem(LS.trim) ?? "1") === "1";
thr.value = (localStorage.getItem(LS.thr) ?? "140");
segThrEl.value = (localStorage.getItem(LS.segthr) ?? "0.38");

function syncLabels(){
  thrVal.textContent = thr.value;
  segThrVal.textContent = Number(segThrEl.value).toFixed(2);
}
syncLabels();

lockBack.addEventListener('change', ()=> localStorage.setItem(LS.lock, lockBack.checked ? "1":"0"));
invertEl.addEventListener('change', ()=> localStorage.setItem(LS.inv, invertEl.checked ? "1":"0"));
autoTrimEl.addEventListener('change', ()=> localStorage.setItem(LS.trim, autoTrimEl.checked ? "1":"0"));
thr.addEventListener('input', () => { localStorage.setItem(LS.thr, thr.value); syncLabels(); });
segThrEl.addEventListener('input', () => { localStorage.setItem(LS.segthr, segThrEl.value); syncLabels(); });

function isBackLabel(label){
  if(!label) return false;
  return /(back|rear|environment|背面|リア|後ろ)/i.test(label);
}

async function listCams({preserve=true, autoPickBack=true} = {}){
  const prev = preserve ? selCam.value : "";
  const saved = localStorage.getItem(LS.cam) || "";
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d => d.kind === 'videoinput');

  selCam.innerHTML = '';
  cams.forEach((c, i) => {
    const opt = document.createElement('option');
    opt.value = c.deviceId;
    opt.textContent = c.label || `Camera ${i+1}`;
    selCam.appendChild(opt);
  });

  if([...selCam.options].some(o => o.value === prev)){ selCam.value = prev; return; }
  if([...selCam.options].some(o => o.value === saved)){ selCam.value = saved; return; }

  if(autoPickBack && lockBack.checked){
    const backOpt = [...selCam.options].find(o => isBackLabel(o.textContent));
    if(backOpt){ selCam.value = backOpt.value; return; }
  }
  if(selCam.options.length) selCam.selectedIndex = 0;
}

selCam.addEventListener('change', () => localStorage.setItem(LS.cam, selCam.value || ""));

function setRoiBox(){
  const stage = roiEl.parentElement;
  const r = stage.getBoundingClientRect();
  roiEl.style.left = (ROI.x * r.width) + 'px';
  roiEl.style.top  = (ROI.y * r.height) + 'px';
  roiEl.style.width  = (ROI.w * r.width) + 'px';
  roiEl.style.height = (ROI.h * r.height) + 'px';
}
window.addEventListener('resize', setRoiBox);

async function startCamera(){
  await listCams({preserve:true, autoPickBack:false});

  try{
    const tmp = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: lockBack.checked ? "environment" : "user" } },
      audio: false
    });
    tmp.getTracks().forEach(t => t.stop());
  }catch(e){}

  await listCams({preserve:true, autoPickBack:true});
  const deviceId = selCam.value || undefined;

  stream = await navigator.mediaDevices.getUserMedia({
    video: {
      deviceId: deviceId ? { exact: deviceId } : undefined,
      facingMode: deviceId ? undefined : { ideal: lockBack.checked ? "environment" : "user" },
      width: { ideal: 1280 },
      height:{ ideal: 720 }
    },
    audio:false
  });

  video.srcObject = stream;
  await video.play();

  btnStart.disabled = true;
  btnStop.disabled  = false;

  overlay.width = video.videoWidth;
  overlay.height = video.videoHeight;

  setRoiBox();
  loop();
}

function stopCamera(){
  cancelAnimationFrame(rafId);
  rafId = null;
  if(stream){
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  video.pause();
  video.srcObject = null;

  btnStart.disabled = false;
  btnStop.disabled  = true;
  outEl.textContent = '—';
  dbgEl.textContent = '';
}

btnStart.onclick = async () => {
  try{ await startCamera(); }
  catch(e){ alert('カメラ開始失敗: ' + (e?.name ? `${e.name}: ${e.message}` : e.message)); }
};
btnStop.onclick = () => stopCamera();

selCam.onchange = async () => {
  localStorage.setItem(LS.cam, selCam.value || "");
  if(!stream) return;
  stopCamera();
  await new Promise(r => setTimeout(r, 200));
  btnStart.onclick();
};

function loop(){
  ctxO.clearRect(0,0,overlay.width,overlay.height);

  const rx = Math.floor(ROI.x * overlay.width);
  const ry = Math.floor(ROI.y * overlay.height);
  const rw = Math.floor(ROI.w * overlay.width);
  const rh = Math.floor(ROI.h * overlay.height);

  work.width = rw; work.height = rh;
  ctxW.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);

  const imageData = ctxW.getImageData(0,0,rw,rh);
  const data = imageData.data;
  const T = parseInt(thr.value, 10);
  const inv = invertEl.checked;

  const bw = new Uint8Array(rw*rh);
  for(let i=0, p=0; i<data.length; i+=4, p++){
    const r = data[i], g = data[i+1], b = data[i+2];
    const y = (r*0.299 + g*0.587 + b*0.114);
    const on = inv ? (y < T) : (y > T);
    bw[p] = on ? 1 : 0;
    const v = on ? 255 : 0;
    data[i]=data[i+1]=data[i+2]=v;
    data[i+3]=255;
  }
  ctxW.putImageData(imageData, 0, 0);

  let trim = {x0:0, w:rw, ok:false};
  if(autoTrimEl.checked){
    trim = autoTrimX(bw, rw, rh);
  }

  // ROI枠（赤）
  ctxO.strokeStyle = 'rgba(255,0,0,.95)';
  ctxO.lineWidth = 3;
  ctxO.strokeRect(rx+1, ry+1, rw-2, rh-2);

  // トリム枠（緑）
  if(trim.ok){
    ctxO.strokeStyle = 'rgba(0,255,180,.95)';
    ctxO.lineWidth = 3;
    ctxO.strokeRect(rx + trim.x0 + 1, ry + 1, trim.w - 2, rh - 2);
  }

  const nd = parseInt(digitsEl.value, 10);
  const decMode = decEl.value;
  const segThr = parseFloat(segThrEl.value);

  const result = recognize7seg(bw, rw, rh, nd, decMode, segThr, trim);

  if(result.text){
    outEl.textContent = result.text;
    dbgEl.textContent = `confidence=${result.conf.toFixed(2)} | ${result.debug}`;
  }else{
    outEl.textContent = '—';
    dbgEl.textContent = result.debug || '';
  }

  rafId = requestAnimationFrame(loop);
}

function autoTrimX(bw, w, h){
  const col = new Uint32Array(w);
  for(let y=0; y<h; y++){
    const base = y*w;
    for(let x=0; x<w; x++){
      col[x] += bw[base + x];
    }
  }
  const colThr = Math.max(2, Math.floor(h * 0.02)); // 2% 以上
  let bestA=-1, bestB=-1, bestLen=0;

  let a=-1;
  for(let x=0; x<w; x++){
    const has = col[x] >= colThr;
    if(has && a<0) a=x;
    if(!has && a>=0){
      const b=x-1, len=b-a+1;
      if(len>bestLen){ bestLen=len; bestA=a; bestB=b; }
      a=-1;
    }
  }
  if(a>=0){
    const b=w-1, len=b-a+1;
    if(len>bestLen){ bestLen=len; bestA=a; bestB=b; }
  }

  if(bestLen < Math.floor(w*0.25)){
    return {x0:0, w:w, ok:false};
  }

  const pad = Math.floor(w*0.02);
  const x1 = Math.max(0, bestA - pad);
  const x2 = Math.min(w-1, bestB + pad);
  return {x0:x1, w:(x2-x1+1), ok:true};
}

function recognize7seg(bw, w, h, nDigits, decimalMode, segOnThr, trim){
  const padX = Math.floor(w*0.01);
  const padY = Math.floor(h*0.08);

  const baseX0 = trim?.ok ? trim.x0 : 0;
  const baseW  = trim?.ok ? trim.w  : w;

  const x0 = baseX0 + padX;
  const y0 = padY;
  const ww = Math.max(1, baseW - padX*2);
  const hh = Math.max(1, h - padY*2);

  const digitW = ww / nDigits;

  const samples = {
    a:[0.50,0.17],
    b:[0.80,0.34],
    c:[0.80,0.73],
    d:[0.50,0.88],
    e:[0.20,0.73],
    f:[0.20,0.34],
    g:[0.50,0.53]
  };

  const map = {
    "1111110":"0",
    "0110000":"1",
    "1101101":"2",
    "1111001":"3",
    "0110011":"4",
    "1011011":"5",
    "1011111":"6",
    "1110000":"7",
    "1111111":"8",
    "1111011":"9"
  };

  let text='';
  let confSum=0;

  for(let di=0; di<nDigits; di++){
    const dx = Math.floor(x0 + di*digitW);
    const dw = Math.max(1, Math.floor(digitW));
    const rad = Math.max(1, Math.floor(Math.min(dw,hh)*0.015));

    let bits='';
    let local=0;

    const order=['a','b','c','d','e','f','g'];
    for(const k of order){
      const [rx,ry]=samples[k];
      const sx=Math.floor(dx + rx*dw);
      const sy=Math.floor(y0 + ry*hh);
      const ratio=sampleWhiteRatio(bw,w,h,sx,sy,rad);
      const on = ratio >= segOnThr;
      bits += on ? '1':'0';
      local += Math.min(1, Math.abs(ratio - segOnThr) / Math.max(0.15, (1-segOnThr)));
    }
    local/=7;

    const digit = map[bits] ?? '?';
    text += digit;
    confSum += local;
  }

  const conf = confSum / nDigits;

  if(text.includes('?')){
    return {text:null, conf:0, debug:`unmatched: ${text} (segThr=${segOnThr.toFixed(2)} trim=${trim?.ok?"on":"off"})`};
  }

  if(decimalMode === 'last' && text.length>=2){
    text = text.slice(0, -1) + '.' + text.slice(-1);
  }

  const camLabel = selCam.selectedOptions?.[0]?.textContent || "";
  return {text, conf, debug:`thr=${thr.value} inv=${invertEl.checked?1:0} trim=${trim?.ok?1:0} segThr=${segOnThr.toFixed(2)} cam="${camLabel}"`};
}

function sampleWhiteRatio(bw,w,h,cx,cy,r){
  let white=0,total=0;
  const x1=Math.max(0,cx-r), x2=Math.min(w-1,cx+r);
  const y1=Math.max(0,cy-r), y2=Math.min(h-1,cy+r);
  for(let y=y1;y<=y2;y++){
    const base=y*w;
    for(let x=x1;x<=x2;x++){
      total++;
      if(bw[base+x]) white++;
    }
  }
  return total ? white/total : 0;
}

navigator.mediaDevices?.addEventListener?.('devicechange', () => listCams({preserve:true, autoPickBack:true}));
listCams({preserve:true, autoPickBack:true}).catch(()=>{});
setRoiBox();
</script>
</body>
</html>
