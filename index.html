<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>7セグ認識 Webアプリ（ROI固定）</title>
<style>
  body { font-family: system-ui, -apple-system, sans-serif; margin: 0; background:#111; color:#eee; }
  .wrap { display:flex; flex-direction:column; gap:10px; padding:10px; max-width:980px; margin:0 auto; }
  .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  button, select, input { font-size:16px; padding:8px 10px; }
  .stage { position:relative; width:100%; aspect-ratio: 16/9; background:#000; overflow:hidden; border-radius:10px; }
  video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
  .roi {
    position:absolute;
    border:2px solid rgba(255,0,0,.9);
    box-shadow: 0 0 0 9999px rgba(0,0,0,.35);
    border-radius:6px;
    pointer-events:none;
  }
  .panel { background:#1b1b1b; padding:10px; border-radius:10px; }
  .k { color:#9ad; }
  .big { font-size:28px; font-weight:700; letter-spacing: .5px; }
  .hint { color:#bbb; font-size:13px; line-height:1.4; }
  .grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  @media (max-width: 700px){ .grid { grid-template-columns: 1fr; } }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <button id="btnStart">カメラ開始</button>
    <button id="btnStop" disabled>停止</button>

    <label>カメラ</label>
    <select id="selCam"></select>

    <label style="display:flex;align-items:center;gap:6px;">
      <input id="lockBack" type="checkbox" checked />
      背面固定
    </label>

    <label>2値化</label>
    <input id="thr" type="range" min="0" max="255" value="140" />
    <span id="thrVal">140</span>

    <label>桁</label>
    <select id="digits">
      <option value="4" selected>4桁</option>
      <option value="5">5桁</option>
    </select>

    <label>小数点</label>
    <select id="decimal">
      <option value="none">なし</option>
      <option value="last" selected>最後の1桁前（xxx.x）</option>
    </select>
  </div>

  <div class="grid">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
      <div id="roi" class="roi"></div>
    </div>

    <div class="panel">
      <div><span class="k">認識結果</span></div>
      <div id="out" class="big">—</div>
      <div class="hint" id="dbg"></div>
      <hr style="border:0;border-top:1px solid #333;margin:10px 0;">
      <div class="hint">
        <div>・iPhone Safariは「停止→再開」で前面に戻ることがあるので、<b>背面固定</b>で背面を選び直すようにしてあります。</div>
        <div>・「2値化」を調整して、背景が黒、数字が白に近くなるのが理想。</div>
      </div>
    </div>
  </div>

  <canvas id="work" style="display:none;"></canvas>
</div>

<script>
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const work = document.getElementById('work');
const ctxO = overlay.getContext('2d', { willReadFrequently:true });
const ctxW = work.getContext('2d', { willReadFrequently:true });

const btnStart = document.getElementById('btnStart');
const btnStop  = document.getElementById('btnStop');
const selCam   = document.getElementById('selCam');
const lockBack = document.getElementById('lockBack');
const thr      = document.getElementById('thr');
const thrVal   = document.getElementById('thrVal');
const digitsEl = document.getElementById('digits');
const decEl    = document.getElementById('decimal');
const outEl    = document.getElementById('out');
const dbgEl    = document.getElementById('dbg');
const roiEl    = document.getElementById('roi');

let stream = null;
let rafId = null;

// ROI（画面比率で固定）
const ROI = { x: 0.18, y: 0.38, w: 0.64, h: 0.24 }; // 0..1

// 選択カメラを保持（停止→再開で前面に戻る対策）
const LS_KEY = "sevenseg_cam_deviceid";
const LS_LOCK = "sevenseg_lockback";
lockBack.checked = (localStorage.getItem(LS_LOCK) ?? "1") === "1";
lockBack.addEventListener('change', ()=> localStorage.setItem(LS_LOCK, lockBack.checked ? "1":"0"));

thr.addEventListener('input', () => thrVal.textContent = thr.value);

function isBackLabel(label){
  if(!label) return false;
  return /(back|rear|environment|背面|リア|後ろ)/i.test(label);
}

async function listCams({preserve=true, autoPickBack=true} = {}){
  const prev = preserve ? selCam.value : "";
  const saved = localStorage.getItem(LS_KEY) || "";
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d => d.kind === 'videoinput');

  selCam.innerHTML = '';
  cams.forEach((c, i) => {
    const opt = document.createElement('option');
    opt.value = c.deviceId;
    opt.textContent = c.label || `Camera ${i+1}`;
    selCam.appendChild(opt);
  });

  // 1) 直前選択を優先
  const hasPrev = [...selCam.options].some(o => o.value === prev);
  if(hasPrev){
    selCam.value = prev;
    return;
  }

  // 2) 保存済みdeviceIdを優先
  const hasSaved = [...selCam.options].some(o => o.value === saved);
  if(hasSaved){
    selCam.value = saved;
    return;
  }

  // 3) 背面っぽいラベルを自動選択（権限許可後に効く）
  if(autoPickBack && lockBack.checked){
    const backOpt = [...selCam.options].find(o => isBackLabel(o.textContent));
    if(backOpt){
      selCam.value = backOpt.value;
      return;
    }
  }

  // 4) それでもダメなら先頭
  if(selCam.options.length) selCam.selectedIndex = 0;
}

selCam.addEventListener('change', () => {
  localStorage.setItem(LS_KEY, selCam.value || "");
});

function setRoiBox(){
  const stage = roiEl.parentElement;
  const r = stage.getBoundingClientRect();
  roiEl.style.left = (ROI.x * r.width) + 'px';
  roiEl.style.top  = (ROI.y * r.height) + 'px';
  roiEl.style.width  = (ROI.w * r.width) + 'px';
  roiEl.style.height = (ROI.h * r.height) + 'px';
}
window.addEventListener('resize', setRoiBox);

async function startCamera(){
  // permission前はラベル空のことがあるが、選択枠だけでも作る
  await listCams({preserve:true, autoPickBack:false});

  // まずは「背面優先」で権限確定（ここでラベルが取れるようになる）
  try{
    const tmp = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: lockBack.checked ? "environment" : "user" },
        width: { ideal: 1280 },
        height:{ ideal: 720 }
      },
      audio: false
    });
    tmp.getTracks().forEach(t => t.stop());
  }catch(e){
    // 失敗しても次でdeviceId固定を試す
  }

  // ラベルが取れる状態で列挙し、背面を選び直す
  await listCams({preserve:true, autoPickBack:true});

  const deviceId = selCam.value || undefined;

  // deviceIdで固定取得（停止→再開でも同じdeviceIdを使う）
  stream = await navigator.mediaDevices.getUserMedia({
    video: {
      deviceId: deviceId ? { exact: deviceId } : undefined,
      // deviceIdが無い場合だけ facingMode を効かせる
      facingMode: deviceId ? undefined : { ideal: lockBack.checked ? "environment" : "user" },
      width: { ideal: 1280 },
      height:{ ideal: 720 }
    },
    audio: false
  });

  video.srcObject = stream;
  await video.play();

  btnStart.disabled = true;
  btnStop.disabled = false;

  overlay.width = video.videoWidth;
  overlay.height = video.videoHeight;

  setRoiBox();
  loop();
}

function stopCamera(){
  cancelAnimationFrame(rafId);
  rafId = null;
  if(stream){
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  // iOS対策：srcObject解除
  video.pause();
  video.srcObject = null;

  btnStart.disabled = false;
  btnStop.disabled = true;
  outEl.textContent = '—';
  dbgEl.textContent = '';
}

btnStart.onclick = async () => {
  try{
    await startCamera();
  }catch(e){
    alert('カメラ開始失敗: ' + (e?.name ? `${e.name}: ${e.message}` : e.message));
  }
};

btnStop.onclick = () => stopCamera();

selCam.onchange = async () => {
  localStorage.setItem(LS_KEY, selCam.value || "");
  if(!stream) return;
  stopCamera();
  await new Promise(r => setTimeout(r, 200));
  btnStart.onclick();
};

function loop(){
  ctxO.clearRect(0,0,overlay.width,overlay.height);

  const rx = Math.floor(ROI.x * overlay.width);
  const ry = Math.floor(ROI.y * overlay.height);
  const rw = Math.floor(ROI.w * overlay.width);
  const rh = Math.floor(ROI.h * overlay.height);

  work.width = rw; work.height = rh;
  ctxW.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);

  const imageData = ctxW.getImageData(0,0,rw,rh);
  const data = imageData.data;
  const T = parseInt(thr.value, 10);

  const bw = new Uint8Array(rw*rh);
  for(let i=0, p=0; i<data.length; i+=4, p++){
    const r = data[i], g = data[i+1], b = data[i+2];
    const y = (r*0.299 + g*0.587 + b*0.114);
    bw[p] = (y > T) ? 1 : 0;
    const v = bw[p] ? 255 : 0;
    data[i]=data[i+1]=data[i+2]=v;
    data[i+3]=255;
  }
  ctxW.putImageData(imageData, 0, 0);

  ctxO.strokeStyle = 'rgba(255,0,0,.95)';
  ctxO.lineWidth = 3;
  ctxO.strokeRect(rx+1, ry+1, rw-2, rh-2);

  const nd = parseInt(digitsEl.value, 10);
  const decMode = decEl.value;
  const result = recognize7seg(bw, rw, rh, nd, decMode);

  if(result.text){
    outEl.textContent = result.text;
    dbgEl.textContent = `confidence=${result.conf.toFixed(2)} | ${result.debug}`;
  }else{
    outEl.textContent = '—';
    dbgEl.textContent = result.debug || '';
  }

  rafId = requestAnimationFrame(loop);
}

function recognize7seg(bw, w, h, nDigits, decimalMode){
  const padX = Math.floor(w*0.02);
  const padY = Math.floor(h*0.10);
  const x0 = padX, y0 = padY, ww = w - padX*2, hh = h - padY*2;

  const digitW = ww / nDigits;

  const samples = {
    a:[0.50,0.18],
    b:[0.82,0.35],
    c:[0.82,0.72],
    d:[0.50,0.88],
    e:[0.18,0.72],
    f:[0.18,0.35],
    g:[0.50,0.53]
  };

  const segOnThr = 0.55;

  const map = {
    "1111110":"0",
    "0110000":"1",
    "1101101":"2",
    "1111001":"3",
    "0110011":"4",
    "1011011":"5",
    "1011111":"6",
    "1110000":"7",
    "1111111":"8",
    "1111011":"9"
  };

  let text = '';
  let confSum = 0;

  for(let di=0; di<nDigits; di++){
    const dx = Math.floor(x0 + di*digitW);
    const dw = Math.floor(digitW);

    let bits = '';
    let localConf = 0;
    const order = ['a','b','c','d','e','f','g'];
    for(const k of order){
      const [rx, ry] = samples[k];
      const sx = Math.floor(dx + rx*dw);
      const sy = Math.floor(y0 + ry*hh);
      const {ratio} = sampleWhiteRatio(bw, w, h, sx, sy, Math.max(2, Math.floor(Math.min(dw,hh)*0.03)));
      const on = ratio >= segOnThr;
      bits += on ? '1':'0';
      localConf += Math.min(1, Math.abs(ratio - segOnThr) / 0.45);
    }
    localConf /= 7;

    const digit = map[bits] ?? '?';
    text += digit;
    confSum += localConf;
  }

  let conf = confSum / nDigits;

  if(text.includes('?')) {
    return { text:null, conf:0, debug:`unmatched: ${text}` };
  }

  if(decimalMode === 'last'){
    if(text.length >= 2){
      text = text.slice(0, text.length-1) + '.' + text.slice(text.length-1);
    }
  }

  const selLabel = selCam.selectedOptions?.[0]?.textContent || "";
  return { text, conf, debug:`thr=${thr.value} digits=${nDigits} cam="${selLabel}"` };
}

function sampleWhiteRatio(bw, w, h, cx, cy, r){
  let white = 0, total = 0;
  const x1 = Math.max(0, cx-r), x2 = Math.min(w-1, cx+r);
  const y1 = Math.max(0, cy-r), y2 = Math.min(h-1, cy+r);
  for(let y=y1; y<=y2; y++){
    for(let x=x1; x<=x2; x++){
      total++;
      if(bw[y*w + x]) white++;
    }
  }
  return { ratio: total ? white/total : 0 };
}

navigator.mediaDevices?.addEventListener?.('devicechange', () => listCams({preserve:true, autoPickBack:true}));
listCams({preserve:true, autoPickBack:true}).catch(()=>{});
setRoiBox();
</script>
</body>
</html>
